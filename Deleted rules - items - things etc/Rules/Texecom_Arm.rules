// ***************************
// Arm alarm by one button (FIXED)
// ***************************

// Optimized for openHAB 5

import org.openhab.core.model.script.actions.things.ThingActions
import org.openhab.core.model.script.actions.ScriptExecution

rule "Quick Arm"
when   
    Item  Tex_QuickArm changed
then
    // Use the triggeringItem variable which is implicitly cast correctly for the new state
    if (triggeringItem.state === ON) {
        // Use .toString == "0" for robust comparison of item states
		if((gAlarmcontact.members.filter[s | s.state.toString != "0"].size == 0) && (Tex_Alarm_Status.state.toString == "0")) { 
			// Use helpers.safeSleep() to avoid blocking threads.
			
			events.sendCommand(Tex_Get_LSTATUS, OFF)
			helpers.safeSleep(500)
			events.sendCommand(Tex_UDP_Send, "KEY9")
			helpers.safeSleep(500)
			events.sendCommand(Tex_UDP_Send, "KEY9")
			helpers.safeSleep(500)
			events.sendCommand(Tex_UDP_Send, "KEY9")
			helpers.safeSleep(500)
			events.sendCommand(Tex_UDP_Send, "KEY9")
			helpers.safeSleep(1000)
			events.sendCommand(Tex_UDP_Send, "KEYY")
			// Sometimes the first KEYY is not processed/received by Texecom, that's why we send it twice
			helpers.safeSleep(750)
			events.sendCommand(Tex_UDP_Send, "KEYY")
			helpers.safeSleep(250)
			events.sendCommand(Tex_Get_LSTATUS, ON)
			// Put the alarm in exit mode
			events.postUpdate(Tex_Alarm_Status, "2")
			events.postUpdate(Tex_QuickArm, OFF)				
		} else {
			logInfo("Alarm","Fast arming failed due to open contacts or the alarm was not in the correct status")
			events.postUpdate(Tex_QuickArm, OFF)	
		}
    } else {
	    /* Do Nothing - luckily there is no one-button-disarm */
    }
end


rule "Quick Arm Visibility"
when   
    Item  gAlarmcontact changed or
	Item  Tex_Alarm_Status changed
then
    // Use .toString == "0" for robust comparison of item states
	if((gAlarmcontact.members.filter[s | s.state.toString != "0"].size == 0) && (Tex_Alarm_Status.state.toString == "0")) { 
		// If this is "true", quick arm can be visible
		events.sendCommand(Tex_QuickArm_visibility, ON)
	} else {
		events.sendCommand(Tex_QuickArm_visibility, OFF)
	}
end

// ***************************
// Limit access to alarm keypad
// ***************************

rule "Limit access to alarm keypad"	
when   
    Item Tex_Alarm_Keypad received update
then
    // Explicit casting to DecimalType can be omitted if you treat it as a Number and add 1
	var teller = (Tex_Alarm_Keypad_counter.state as Number).intValue + 1
	events.postUpdate(Tex_Alarm_Keypad_counter, teller)

    // Compare as Number or use .toString comparison consistently
	if ((Tex_Alarm_Keypad_counter.state as Number) < 99921) { 
		events.sendCommand(Tex_UDP_Send, Tex_Alarm_Keypad.state.toString)
		logInfo("Texecom", "Key Pressed: {}", Tex_Alarm_Keypad.state) // Modern logging
	} else {
		events.sendCommand(Tex_Alarm_Keypad_visibility, OFF)
		logInfo("Alarm","There have been too many attempts. Keypad will be closed temporarily")
	}
end

rule "Reset access to alarm keypad"
when   
   	Time cron "0 0/5 * 1/1 * ? *" // Runs every 5 minutes
then
	// logInfo("Alarm","Alarm keypad reset counter")	
	events.sendCommand(Tex_Alarm_Keypad_counter, "0")
	events.sendCommand(Tex_Alarm_Keypad_visibility, ON)
end

// ***************************
// Display the history of the last 10 events (FIXED)
// ***************************

rule "History of last 10 events - part 1"
when   
    Item Tex_History_00 changed
then
    // Use events.postUpdate throughout
	events.postUpdate(Tex_History_10, Tex_History_09.state.toString)
	events.postUpdate(Tex_History_09, Tex_History_08.state.toString)
	events.postUpdate(Tex_History_08, Tex_History_07.state.toString)
	events.postUpdate(Tex_History_07, Tex_History_06.state.toString)
	events.postUpdate(Tex_History_06, Tex_History_05.state.toString)
	events.postUpdate(Tex_History_05, Tex_History_04.state.toString)
	events.postUpdate(Tex_History_04, Tex_History_03.state.toString)
	events.postUpdate(Tex_History_03, Tex_History_02.state.toString)
	events.postUpdate(Tex_History_02, Tex_History_01.state.toString)
	events.postUpdate(Tex_History_01, Tex_History_00.state.toString)

    // This section modifies item labels, which works but might be better handled in the UI configuration
    // helpers.safeSleep(100) // Sleep is unlikely to be needed for UI label updates

	// Note: Directly modifying item labels in rules is a legacy approach. 
    // It's generally better to let the UI (Main UI, HABPanel, etc.) render the item label using the item's state.

end


rule "History of last 10 events - part 2 - Windows"
when   
    Item gWindows received update
then
	// Avoid Thread::sleep. The lastUpdate property typically has the correct value by the time the rule triggers.
	var event = gWindows.members.sortBy[lastUpdate].last
    // Use standard Java Time formatting compatible with openHAB 5
	var event_update = event.lastUpdate.toZonedDateTime.format(java.time.format.DateTimeFormatter.ofPattern("dd-MM-yy HH:mm"))
	var event_label = event.label.toString.split("   ")
    // Ensure the map file is correct
	var event_status = transform("MAP","windows.map",event.state.toString)
	events.postUpdate(Tex_History_00, event_update + " - " + event_label.get(0) + " - " + event_status)	
end

rule "History of last 10 events - part 3 - doors"
when   
    Item gDoor received update
then
	// Avoid Thread::sleep
	var event = gDoor.members.sortBy[lastUpdate].last
	var event_update = event.lastUpdate.toZonedDateTime.format(java.time.format.DateTimeFormatter.ofPattern("dd-MM-yy HH:mm"))
	var event_label = event.label.toString.split("   ")
	var event_status = transform("MAP","tex_contacts.map",event.state.toString)
	events.postUpdate(Tex_History_00, event_update + " - " + event_label.get(0) + " - " + event_status)
end

rule "History of last 10 events - part 4 - glass breakage"
when   
    Item gBrokenglass received update
then
	// Avoid Thread::sleep
	var event = gBrokenglass.members.sortBy[lastUpdate].last
	var event_update = event.lastUpdate.toZonedDateTime.format(java.time.format.DateTimeFormatter.ofPattern("dd-MM-yy HH:mm"))
	var event_label = event.label.toString.split("   ")
	var event_status = transform("MAP","tex_contacts.map",event.state.toString)
	events.postUpdate(Tex_History_00, event_update + " - " + event_label.get(0) + " - " + event_status)
end

rule "History of last 10 events - part 5 - alarm status"
when   
   Item Tex_Alarm_Status changed
then
	var event = Tex_Alarm_Status
    // Use standard Java Time formatting compatible with openHAB 5
	var event_update = event.lastUpdate.toZonedDateTime.format(java.time.format.DateTimeFormatter.ofPattern("dd-MM-yy HH:mm"))
	var event_status = transform("MAP","tex_alarmstatus.map",event.state.toString)
	var event_user = transform("MAP","tex_alarmusers.map",Tex_Alarm_ArmDisarmUser.state.toString)
    
    if (Tex_Alarm_Status.state.toString != "2") {
		events.postUpdate(Tex_History_00, event_update + " " + event_status + " by " + event_user)
	}
end