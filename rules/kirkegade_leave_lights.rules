// ============================================================================
// Kirkegade 50 - Smart Lights On Exit/Enter (Dream Catcher Phone)
// ============================================================================
// Automatically manage lights when leaving/entering home via geofence
// - On EXIT: Save which lights are ON, then turn them OFF
// - On ENTER: Restore only the lights that were ON when you left
//
// Target geofence: "Garage Opener - Kirkegade 50"
// Controlled lights: All lights in Lights group (excludes outdoor/heating valves)
// ============================================================================

import java.time.LocalDateTime
import java.util.Map

// Global variable to store the state of lights when leaving
var Map<String, String> savedLightStates = null
var LocalDateTime lastExitTime = null

// ============================================================================
// RULE 1: Save and Turn OFF Lights When Leaving
// ============================================================================

rule "Kirkegade Lights - Save State and Turn OFF on Exit"
when
    Item Vehicle1_GeofenceId changed from 1
then
    // Check if automation is enabled
    if (Vehicle1_AutoLightsEnabled.state != ON) {
        logInfo("Kirkegade Lights", "Smart Lights automation is disabled - skipping")
        return
    }
    
    // We're leaving Kirkegade 50 (geofence ID 1)
    logInfo("Kirkegade Lights", "Dream Catcher exiting Kirkegade 50 (geofence 1) - saving light states")
    
    // Create a new map to store light states
    savedLightStates = newHashMap()
    lastExitTime = LocalDateTime.now
    
    // Iterate through all lights in the Lights group
    Lights.members.forEach[ light |
        val lightState = light.state
        val lightName = light.name
        
        // Skip Terndrupvej lights (different location)
        if (lightName.startsWith("Light_Terndrup") || lightName.contains("Terndrupvej")) {
            logInfo("Kirkegade Lights", "  Skipping Terndrupvej light: " + lightName)
            return
        }
        
        // Check if light is ON (for switches) or brightness > 0 (for dimmers/numbers)
        var shouldSave = false
        var stateValue = ""
        
        if (lightState == ON) {
            // Switch is ON
            shouldSave = true
            stateValue = "ON"
        } else if (lightState instanceof Number || lightState instanceof DecimalType) {
            // Dimmer or Number type (including _Constant items) - check if brightness > 0
            val brightness = (lightState as Number).intValue
            if (brightness > 0) {
                shouldSave = true
                stateValue = brightness.toString
            }
        }
        
        if (shouldSave) {
            savedLightStates.put(light.name, stateValue)
            logInfo("Kirkegade Lights", "  Saved: " + light.name + " = " + stateValue)
            
            // Turn off the light (use 0 for dimmers/numbers, OFF for switches)
            if (stateValue == "ON") {
                light.sendCommand(OFF)
            } else {
                light.sendCommand(0)
            }
        }
    ]
    
    val lightsCount = savedLightStates.size
    logInfo("Kirkegade Lights", "Saved " + lightsCount + " lights that were ON. All lights turned OFF.")
end

// ============================================================================
// RULE 2: Restore Saved Lights When Entering
// ============================================================================

rule "Kirkegade Lights - Restore ON Lights on Enter"
when
    Item Vehicle1_GeofenceId changed to 1
then
    // Check if automation is enabled
    if (Vehicle1_AutoLightsEnabled.state != ON) {
        logInfo("Kirkegade Lights", "Smart Lights automation is disabled - skipping")
        return
    }
    
    // We're entering Kirkegade 50 (geofence ID 1)
    logInfo("Kirkegade Lights", "Dream Catcher entering Kirkegade 50 (geofence 1) - restoring light states")
    
    if (savedLightStates !== null && !savedLightStates.isEmpty) {
        // Calculate time since exit
        var timeSinceExit = ""
        if (lastExitTime !== null) {
            val minutesAway = java.time.Duration.between(lastExitTime, LocalDateTime.now).toMinutes
            timeSinceExit = " (away for " + minutesAway + " minutes)"
        }
        
        logInfo("Kirkegade Lights", "Restoring " + savedLightStates.size + " lights" + timeSinceExit)
        
        // Restore each saved light
        savedLightStates.keySet.forEach[ lightName |
            val light = Lights.members.findFirst[ l | l.name == lightName ]
            
            if (light !== null) {
                val savedValue = savedLightStates.get(lightName)
                
                // Restore to previous state (ON for switches, or brightness level for dimmers)
                if (savedValue == "ON") {
                    logInfo("Kirkegade Lights", "  Restoring: " + lightName + " = ON")
                    light.sendCommand(ON)
                } else {
                    // Restore dimmer to previous brightness
                    logInfo("Kirkegade Lights", "  Restoring: " + lightName + " = " + savedValue + "%")
                    light.sendCommand(savedValue)
                }
            } else {
                logWarn("Kirkegade Lights", "  Could not find light: " + lightName)
            }
        ]
        
        logInfo("Kirkegade Lights", "Light restoration complete")
    } else {
        logInfo("Kirkegade Lights", "No saved light states found - all lights remain off")
    }
end

// ============================================================================
// RULE 3: Clear Saved States on System Restart
// ============================================================================

rule "Kirkegade Lights - Initialize on System Start"
when
    System started
then
    savedLightStates = null
    lastExitTime = null
    logInfo("Kirkegade Lights", "System started - light state memory cleared")
end
